class Solution {
public:
    using ll=long long;
    const int mod=1e9+7;

    ll  solve(string &s,int i,int &n){
        if(i==n)return 1; // 1 valid partition mil gaya 
        if(s[i]=='0') return 0; // 0 ke aage sab bekar hai

        ll takeone=0;
        if(s[i]=='*')takeone=(solve(s,i+1,n)*9)%mod;
        else takeone= (solve(s,i+1,n))%mod;

        ll taketwo=0;
        if(i+1<n){
            if(s[i]=='*'&& s[i+1]=='*'){
                taketwo+=(solve(s,i+2,n)*15)%mod; //11-26
            }
            else if(s[i]=='*'){
                if(s[i+1]>= '0' && s[i+1]<='6') taketwo+=(solve(s,i+2,n)*2)%mod; //can be 1 or 2
                else taketwo+=(solve(s,i+2,n))%mod;
            }
            else if(s[i+1]=='*'){
                if(s[i]=='1') taketwo+=(solve(s,i+2,n)*9)%mod; //can be 11-19
                else if(s[i] == '2') taketwo+=(solve(s,i+2,n)*6)%mod; //can be 21-26
            }
            else {
                if(s[i]=='1' || (s[i]=='2' && s[i+1]<='6')) taketwo+=(solve(s,i+2,n))%mod;
            }
        }
        return (takeone+taketwo)%mod;
    }
    int numDecodings(string s) {
        int n = s.length();
        return solve(s,0,n);
    }
};



class Solution {
public:
    using ll=long long;
    const int mod=1e9+7;
    vector<ll>dp;
    ll  solve(string &s,int i,int &n){
        if(i==n)return 1; // 1 valid partition mil gaya 
        if(s[i]=='0') return 0; // 0 ke aage sab bekar hai
        if(dp[i]!=-1)return dp[i];
        ll takeone=0;
        if(s[i]=='*')takeone=(solve(s,i+1,n)*9)%mod;
        else takeone= (solve(s,i+1,n))%mod;

        ll taketwo=0;
        if(i+1<n){
            if(s[i]=='*'&& s[i+1]=='*'){
                taketwo+=(solve(s,i+2,n)*15)%mod; //11-26
            }
            else if(s[i]=='*'){
                if(s[i+1]>= '0' && s[i+1]<='6') taketwo+=(solve(s,i+2,n)*2)%mod; //can be 1 or 2
                else taketwo+=(solve(s,i+2,n))%mod;
            }
            else if(s[i+1]=='*'){
                if(s[i]=='1') taketwo+=(solve(s,i+2,n)*9)%mod; //can be 11-19
                else if(s[i] == '2') taketwo+=(solve(s,i+2,n)*6)%mod; //can be 21-26
            }
            else {
                if(s[i]=='1' || (s[i]=='2' && s[i+1]<='6')) taketwo+=(solve(s,i+2,n))%mod;
            }
        }
        return dp[i]=(takeone+taketwo)%mod;
    }
    int numDecodings(string s) {
        int n = s.length();
        dp.resize(n,-1);
        return solve(s,0,n);
    }
};


class Solution {
public:
    using ll = long long;
    const ll MOD = 1000000007LL;

    int numDecodings(string s) {
        int n = s.size();
        vector<ll> dp(n+1, 0);
        dp[n] = 1; // empty suffix

        for (int i = n-1; i >= 0; --i) {
            if (s[i] == '0') {
                dp[i] = 0;
                continue;
            }

            ll ways = 0;
            // single char
            if (s[i] == '*') {
                ways = (ways + 9 * dp[i+1]) % MOD;
            } else {
                ways = (ways + dp[i+1]) % MOD;
            }

            // two chars
            if (i + 1 < n) {
                if (s[i] == '*' && s[i+1] == '*') {
                    // 11..19 (9) and 21..26 (6) => 15
                    ways = (ways + 15 * dp[i+2]) % MOD;
                } else if (s[i] == '*') {
                    // * followed by digit d
                    if (s[i+1] >= '0' && s[i+1] <= '6') {
                        // * can be 1 or 2 -> two valid pairs (10/20, 11/21, ..., 16/26)
                        ways = (ways + 2 * dp[i+2]) % MOD;
                    } else {
                        // d in '7'..'9' -> only * = 1 works (17..19)
                        ways = (ways + dp[i+2]) % MOD;
                    }
                } else if (s[i+1] == '*') {
                    // digit followed by *
                    if (s[i] == '1') {
                        // 11..19 => 9 possibilities
                        ways = (ways + 9 * dp[i+2]) % MOD;
                    } else if (s[i] == '2') {
                        // 21..26 => 6 possibilities
                        ways = (ways + 6 * dp[i+2]) % MOD;
                    }
                } else {
                    // both digits
                    int num = (s[i]-'0')*10 + (s[i+1]-'0');
                    if (num >= 10 && num <= 26) ways = (ways + dp[i+2]) % MOD;
                }
            }

            dp[i] = ways;
        }

        return (int)dp[0];
    }
};
