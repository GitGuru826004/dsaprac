class Solution {
public:
    vector<int>dp;
    int solve(vector<int>&st,int i,unordered_map<int,int>&freq){
        int n =st.size();
        if(i>=n)return 0;
        if(dp[i]!=-1)return dp[i];

        int take=freq[st[i]]*st[i];
        if(i+1<n && st[i+1]==st[i]+1){
            take+=solve(st,i+2,freq);
        }
        else{
            take+=solve(st,i+1,freq);
        }
        int nottake= solve(st,i+1,freq);
        return dp[i]=max(take,nottake);
    }
    int deleteAndEarn(vector<int>& nums) {
        vector<int>st;
        unordered_map<int,int>freq;
        for(int x:nums){
            if(freq[x]==0)st.push_back(x);
            freq[x]++;
        }
        sort(st.begin(),st.end());
        dp.resize(st.size(),-1);
        return solve(st,0,freq);
    }
};



class Solution {
public:

    int deleteAndEarn(vector<int>& nums) {
        vector<int>st;
        unordered_map<int,int>freq;
        for(int x:nums){
            if(freq[x]==0)st.push_back(x);
            freq[x]++;
        }
        sort(st.begin(),st.end());
        int n =st.size();

        vector<int>dp(n+2,0); //as dp[i+2] tak ja rahe 
        for(int i=n-1;i>=0;i--){
            int take=freq[st[i]]*st[i];
            if(i+1<n && st[i+1]==st[i]+1){
                take+=dp[i+2];
            }
            else{
                take+=dp[i+1];
            }
            int nottake= dp[i+1];
            dp[i]=max(take,nottake);
        }
        return dp[0];
    }
};




class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        vector<int> st;
        unordered_map<int,int> freq;
        for (int x : nums) {
            if (freq[x] == 0) st.push_back(x);
            freq[x]++;
        }
        sort(st.begin(), st.end());
        int n = st.size();

        vector<int> dp(n, 0);
        dp[0] = st[0] * freq[st[0]];

        for (int i = 1; i < n; i++) {
            int take = st[i] * freq[st[i]];
            if (st[i] == st[i-1] + 1) {
                take += (i >= 2 ? dp[i-2] : 0);
            } else {
                take += dp[i-1];
            }
            int nottake = dp[i-1];
            dp[i] = max(take, nottake);
        }
        return dp[n-1];
    }
};
